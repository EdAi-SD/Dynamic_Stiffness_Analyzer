# üìä APLICACI√ìN DE RIGIDEZ DIN√ÅMICA - DOCUMENTACI√ìN COMPLETA
 Bienvenido a la documentaci√≥n integral de la aplicaci√≥n de rigidez din√°mica. Aqu√≠ encontrar√°s explicaciones detalladas sobre cada aspecto del software, desde la teor√≠a b√°sica hasta la interpretaci√≥n avanzada de resultados. El objetivo es que cualquier usuario, sin importar su nivel t√©cnico, pueda comprender el funcionamiento, los m√©todos, la justificaci√≥n de cada par√°metro y apartado, y sacar el m√°ximo provecho de la herramienta. Se incluyen conceptos matem√°ticos, ejemplos pr√°cticos, recomendaciones y aclaraciones para facilitar el aprendizaje y la aplicaci√≥n en casos reales.

## üìã √çNDICE

**¬øC√≥mo usar el √≠ndice?**
El √≠ndice te permite navegar r√°pidamente por las diferentes secciones del documento. Cada apartado est√° pensado para abordar una necesidad espec√≠fica: desde la descripci√≥n general y el contexto de uso, hasta la instalaci√≥n, el troubleshooting y la referencia de la API. Si eres nuevo en el an√°lisis de rigidez din√°mica, te recomendamos empezar por la descripci√≥n general y la gu√≠a de usuario. Si buscas detalles t√©cnicos o integraci√≥n avanzada, consulta los algoritmos, la API y las notas de versi√≥n.

1. [Descripci√≥n General](#descripci√≥n-general)
2. [Caracter√≠sticas Principales](#caracter√≠sticas-principales)
3. [Arquitectura del Sistema](#arquitectura-del-sistema)
4. [Sistema de Cach√© Inteligente](#sistema-de-cach√©-inteligente)
5. [Funcionalidades Detalladas](#funcionalidades-detalladas)
6. [Interfaz de Usuario](#interfaz-de-usuario)
7. [Algoritmos y M√©todos](#algoritmos-y-m√©todos)
8. [Optimizaciones de Rendimiento](#optimizaciones-de-rendimiento)
9. [Gu√≠a de Instalaci√≥n](#gu√≠a-de-instalaci√≥n)
10. [Gu√≠a de Usuario](#gu√≠a-de-usuario)
11. [Troubleshooting](#troubleshooting)
12. [API Reference](#api-reference)

---

## üìñ DESCRIPCI√ìN GENERAL

**¬øQu√© encontrar√°s en esta secci√≥n?**
Aqu√≠ se explica el concepto de rigidez din√°mica, su importancia en ingenier√≠a y c√≥mo la aplicaci√≥n facilita el an√°lisis experimental. Se incluyen ejemplos de situaciones donde el an√°lisis es relevante, como ensayos de laboratorio, diagn√≥stico de estructuras y validaci√≥n de modelos num√©ricos. Adem√°s, se detalla el prop√≥sito de la herramienta y c√≥mo puede adaptarse a diferentes necesidades y formatos de datos.

**¬øQu√© es la rigidez din√°mica?**
La rigidez din√°mica es una propiedad fundamental de las estructuras que indica c√≥mo resisten la deformaci√≥n bajo cargas que var√≠an en el tiempo. Analizarla permite identificar modos de vibraci√≥n, zonas d√©biles y estimar el amortiguamiento, lo que es clave para el dise√±o y diagn√≥stico estructural.

**¬øPor qu√© usar esta aplicaci√≥n?**
Esta herramienta permite procesar datos experimentales de manera profesional, automatizando tareas complejas como el filtrado, la segmentaci√≥n temporal, el c√°lculo espectral y la visualizaci√≥n avanzada. As√≠, el usuario puede centrarse en la interpretaci√≥n de resultados y la toma de decisiones.

### üéØ **Prop√≥sito**

**¬øPor qu√© es importante el prop√≥sito?**
El prop√≥sito define la raz√≥n de ser de la aplicaci√≥n: facilitar el an√°lisis de rigidez din√°mica y amortiguamiento en estructuras, automatizando tareas complejas y permitiendo al usuario centrarse en la interpretaci√≥n de resultados. Se busca que la herramienta sea intuitiva, robusta y flexible, adapt√°ndose a diferentes ensayos y formatos de archivo. Esto permite ahorrar tiempo, reducir errores y mejorar la calidad del an√°lisis experimental.
El prop√≥sito de la aplicaci√≥n es facilitar el an√°lisis de rigidez din√°mica y amortiguamiento en estructuras mediante el procesamiento de se√±ales de aceler√≥metros y sensores de fuerza. Est√° dise√±ada para ser intuitiva, robusta y flexible, permitiendo trabajar con diferentes formatos de archivo y adaptar los par√°metros de an√°lisis a cada ensayo.
Aplicaci√≥n web avanzada para an√°lisis de **rigidez din√°mica** de estructuras mediante procesamiento de se√±ales de aceler√≥metros y sensores de fuerza. Desarrollada con **Dash/Plotly** para an√°lisis cient√≠fico e ingenieril.

### üèóÔ∏è **Contexto de Uso**

**¬øEn qu√© situaciones se recomienda usar la aplicaci√≥n?**
La aplicaci√≥n es √∫til en una amplia variedad de escenarios: ensayos de impacto, an√°lisis modal experimental, caracterizaci√≥n de amortiguamiento, evaluaci√≥n de propiedades din√°micas y validaci√≥n de modelos num√©ricos. Tambi√©n es ideal para investigaci√≥n en ingenier√≠a estructural y desarrollo de nuevas metodolog√≠as de an√°lisis. Se recomienda su uso tanto en laboratorio como en campo, y es compatible con equipos de adquisici√≥n est√°ndar.
**¬øEn qu√© situaciones se usa?**
La aplicaci√≥n es √∫til en ensayos de laboratorio, validaci√≥n de modelos num√©ricos, diagn√≥stico de estructuras existentes y desarrollo de nuevas metodolog√≠as de an√°lisis modal. Permite trabajar tanto con datos de impacto como con vibraciones forzadas, y es compatible con equipos de adquisici√≥n est√°ndar.
- **Ensayos de impacto** con martillo instrumentado
- **An√°lisis modal experimental**
- **Caracterizaci√≥n de amortiguamiento**
- **Evaluaci√≥n de propiedades din√°micas** de estructuras
- **Investigaci√≥n en ingenier√≠a estructural**

### ‚ö° **Caracter√≠sticas Clave**

**¬øQu√© aporta cada caracter√≠stica?**
Cada caracter√≠stica est√° dise√±ada para resolver una necesidad real en el an√°lisis experimental. El procesamiento en tiempo real permite iterar r√°pidamente sobre los datos; el sistema de cach√© optimiza el trabajo con datasets grandes; la interfaz moderna facilita la interacci√≥n; los c√°lculos robustos aseguran resultados fiables; la exportaci√≥n flexible permite documentar y compartir resultados; y la visualizaci√≥n 3D avanzada ayuda a interpretar la evoluci√≥n temporal y frecuencial de la respuesta estructural.
Cada caracter√≠stica responde a una necesidad real en el an√°lisis experimental:
- Procesamiento en tiempo real: evita esperas y permite iterar r√°pidamente sobre los datos.
- Sistema de cach√©: acelera el trabajo en datasets grandes y repetitivos.
- Interfaz moderna: facilita la interacci√≥n y reduce errores de usuario.
- C√°lculos robustos: emplea algoritmos validados en la literatura t√©cnica.
- Exportaci√≥n flexible: permite documentar y compartir resultados f√°cilmente.
- ‚úÖ **Procesamiento en tiempo real** de se√±ales
- ‚úÖ **Sistema de cach√© inteligente** para optimizaci√≥n
- ‚úÖ **Interfaz web moderna** con feedback visual
- ‚úÖ **C√°lculos cient√≠ficos robustos**
- ‚úÖ **Exportaci√≥n de datos** en m√∫ltiples formatos
- ‚úÖ **Visualizaci√≥n 3D avanzada**

---

## üöÄ CARACTER√çSTICAS PRINCIPALES

### üìÅ **Gesti√≥n de Archivos**

**¬øPor qu√© es importante la gesti√≥n de archivos?**
La capacidad de trabajar con diferentes formatos de archivo (CSV, TXT Catman, XLSX) permite adaptar la aplicaci√≥n a diversos sistemas de adquisici√≥n y evitar errores de compatibilidad. La autodetecci√≥n y validaci√≥n robusta aseguran que los datos sean consistentes y aptos para el an√°lisis, facilitando el trabajo del usuario y mejorando la fiabilidad de los resultados.
**¬øPor qu√© soportar varios formatos?**
En la pr√°ctica, los datos pueden provenir de diferentes sistemas de adquisici√≥n. Por eso, la aplicaci√≥n detecta autom√°ticamente el formato y adapta el procesamiento, evitando errores y facilitando el trabajo del usuario.
<div align="center">

|      Formato       |            Descripci√≥n            |    Soporte     |
|:------------------:|:---------------------------------:|:--------------:|
|   **CSV**          | Archivos est√°ndar con separadores |  ‚úÖ Completo   |
| **TXT Catman**     |      Formato HBM Catman           |  ‚úÖ Completo   |
|   **XLSX**         |             Excel                 |  ‚úÖ Completo   |
| **Autodetecci√≥n**  |   Reconocimiento autom√°tico       | ‚úÖ Autom√°tico  |

</div>

### üîß **Procesamiento de Se√±ales**
**¬øPor qu√© filtrar y cortar las se√±ales?**
Las se√±ales reales suelen contener ruido, offset y componentes no deseadas. Los filtros y el corte temporal permiten limpiar los datos y centrarse en la parte relevante del ensayo, mejorando la fiabilidad del an√°lisis espectral y modal.

**Explicaci√≥n de cada filtro y m√©todo:**
- **Filtro mediana**: Elimina picos de ruido impulsivo que pueden aparecer por interferencias el√©ctricas o impactos no deseados. Es especialmente √∫til para limpiar la se√±al sin distorsionar los transitorios importantes, como el inicio de un impacto.
- **Filtro paso alto**: Suprime componentes de baja frecuencia, como el offset o la deriva lenta de los sensores, permitiendo que el an√°lisis se centre en las vibraciones relevantes. Esto mejora la precisi√≥n en la identificaci√≥n de modos de vibraci√≥n.
- **Filtro multibanda**: Permite aislar rangos de frecuencia espec√≠ficos, agrupando autom√°ticamente bandas cercanas y optimizando el dise√±o del filtro para preservar la forma de la se√±al. Es √∫til para enfocar el an√°lisis en zonas de inter√©s y reducir el efecto de ruido fuera de banda.
- **Ventaneo adaptativo**: Ajusta la ventana de an√°lisis seg√∫n el tipo de se√±al y su comportamiento temporal, optimizando la detecci√≥n de transitorios y el c√°lculo espectral. Por ejemplo, para se√±ales de impacto, detecta autom√°ticamente el decaimiento y aplica una ventana exponencial.
- **Corte temporal**: Selecciona una porci√≥n espec√≠fica de la se√±al para el an√°lisis, permitiendo excluir zonas irrelevantes o ruidosas. Esto es fundamental para mejorar la fiabilidad de los resultados espectrales y modales.
- **Filtro mediana**: Eliminaci√≥n de ruido impulsivo
- **Filtro paso alto**: Eliminaci√≥n de offset y deriva
- **Filtro multibanda**: Aislamiento de frecuencias espec√≠ficas
- **Ventaneo adaptativo**: Optimizado para transitorios
- **Corte temporal**: Selecci√≥n de ventanas de an√°lisis

### üìä **An√°lisis Espectral**

**¬øC√≥mo interpretar los resultados espectrales?**
El an√°lisis espectral permite identificar las frecuencias naturales, zonas de resonancia y antiresonancia, y estimar el amortiguamiento. La visualizaci√≥n de la FFT y el waterfall 3D ayuda a comprender c√≥mo evoluciona la respuesta en el tiempo y a validar la calidad de la medici√≥n mediante la coherencia. Se recomienda analizar los picos espectrales, la magnitud y fase de la rigidez din√°mica, y la coherencia para asegurar resultados fiables.
**¬øQu√© es la FFT y por qu√© es importante?**
La Transformada R√°pida de Fourier (FFT) permite descomponer la se√±al en sus componentes frecuenciales, identificando modos de vibraci√≥n y zonas de inter√©s. El an√°lisis waterfall 3D muestra c√≥mo evoluciona la respuesta en el tiempo, y la funci√≥n de transferencia (FRF) relaciona la excitaci√≥n y la respuesta para calcular la rigidez din√°mica.

**¬øPor qu√© usar an√°lisis espectral?**
El an√°lisis espectral es esencial para entender c√≥mo responde una estructura a diferentes frecuencias de excitaci√≥n. Permite identificar las frecuencias naturales (modos propios), zonas de resonancia y antiresonancia, y estimar el amortiguamiento. Adem√°s, ayuda a validar la calidad de la medici√≥n mediante la coherencia y a detectar problemas experimentales como ruido excesivo o errores de sincronizaci√≥n.

**¬øQu√© representa cada par√°metro?**
- `H(œâ)`: Relaciona la respuesta (aceleraci√≥n) y la excitaci√≥n (fuerza) en el dominio de la frecuencia. Es la base para calcular la rigidez din√°mica y el amortiguamiento.
- `K(œâ)`: Indica cu√°nta fuerza se necesita para producir una determinada aceleraci√≥n en cada frecuencia. Valores bajos de K(œâ) suelen indicar resonancias, mientras que valores altos pueden se√±alar antiresonancias o zonas r√≠gidas.
- `S_xf(œâ)`, `S_ff(œâ)`, `S_xx(œâ)`: Permiten calcular estimadores robustos de la FRF, minimizando el efecto del ruido y mejorando la fiabilidad de los resultados.
- `Œ≥¬≤(œâ)`: Mide la calidad de la medici√≥n en cada frecuencia. Valores cercanos a 1 indican que la se√±al de fuerza y la de aceleraci√≥n est√°n bien correlacionadas, lo que significa que el an√°lisis es confiable en ese rango.

**Explicaci√≥n de m√©todos avanzados:**
- **FFT optimizada**: Utiliza algoritmos eficientes y ventaneo inteligente para procesar grandes vol√∫menes de datos sin perder resoluci√≥n espectral.
- **An√°lisis waterfall 3D**: Segmenta la se√±al en ventanas temporales y calcula la FFT de cada segmento, permitiendo visualizar c√≥mo cambian los modos de vibraci√≥n a lo largo del tiempo.
- **Funci√≥n de transferencia (FRF) robusta**: Emplea estimadores H1, H2 y Hv para obtener resultados precisos incluso en presencia de ruido.
- **Coherencia**: Valida la calidad de la medici√≥n y ayuda a identificar rangos de frecuencia donde los resultados son fiables.
- **Rigidez din√°mica compleja**: Permite analizar tanto la magnitud como la fase de la rigidez, proporcionando informaci√≥n sobre el comportamiento din√°mico y el amortiguamiento.

**Explicaci√≥n de par√°metros y f√≥rmulas:**
- `H(œâ)`: Funci√≥n de respuesta en frecuencia, calculada como el cociente entre la respuesta y la fuerza en el dominio de la frecuencia.
- `K(œâ) = -œâ¬≤ / H(œâ)`: Rigidez din√°mica, donde œâ es la frecuencia angular (œâ = 2œÄf) y H(œâ) la FRF.
- `S_xf(œâ)`, `S_ff(œâ)`, `S_xx(œâ)`: Espectros cruzados y de potencia, usados en los estimadores robustos H1, H2 y Hv para minimizar el efecto del ruido.
- `Œ≥¬≤(œâ)`: Coherencia, indicador de la calidad de la medici√≥n en cada frecuencia (valor cercano a 1 = alta fiabilidad).
- **FFT optimizada** con ventaneo inteligente
- **An√°lisis waterfall 3D** con segmentaci√≥n adaptativa
- **Funci√≥n de transferencia (FRF)** robusta
- **Coherencia** para validaci√≥n de medidas
- **Rigidez din√°mica** compleja

### üìà **Visualizaci√≥n Avanzada**
- **Gr√°ficos interactivos** con Plotly
- **Vista 3D** con controles de c√°mara
- **Escalas logar√≠tmicas/lineales**
- **M√∫ltiples se√±ales simult√°neas**
- **Interfaz responsive**

**Explicaci√≥n de cada funcionalidad visual:**
- **Gr√°ficos interactivos**: Permiten al usuario explorar los datos, hacer zoom, seleccionar regiones de inter√©s y comparar diferentes se√±ales de manera intuitiva.
- **Vista 3D**: Facilita la interpretaci√≥n de la evoluci√≥n temporal y frecuencial de la respuesta estructural, mostrando c√≥mo cambian los modos de vibraci√≥n a lo largo del ensayo.
- **Controles de c√°mara**: El usuario puede rotar, acercar y alejar la vista para analizar detalles espec√≠ficos en el gr√°fico waterfall 3D.
- **Escalas logar√≠tmicas/lineales**: La escala logar√≠tmica es √∫til para visualizar rangos amplios de frecuencia y amplitud, mientras que la lineal permite un an√°lisis detallado en zonas espec√≠ficas.
- **M√∫ltiples se√±ales simult√°neas**: Es posible comparar diferentes ejes de aceleraci√≥n y la fuerza, lo que ayuda a identificar modos acoplados y validar la consistencia de los datos.
- **Interfaz responsive**: La aplicaci√≥n se adapta autom√°ticamente al tama√±o de la pantalla y al dispositivo, asegurando una experiencia de usuario √≥ptima tanto en escritorio como en dispositivos m√≥viles.

---

## üèóÔ∏è ARQUITECTURA DEL SISTEMA

**¬øPor qu√© es importante la arquitectura modular?**
La arquitectura modular facilita el mantenimiento, la escalabilidad y la incorporaci√≥n de nuevas funcionalidades. Cada m√≥dulo se encarga de una tarea espec√≠fica: el frontend gestiona la interacci√≥n con el usuario y la visualizaci√≥n; el backend realiza el procesamiento de datos y c√°lculos; el sistema de cach√© optimiza el rendimiento; y las utilidades proporcionan funciones de validaci√≥n y manejo de errores. Esta organizaci√≥n permite que el software sea robusto, flexible y f√°cil de actualizar.

### üì¶ **Estructura Modular**

**Explicaci√≥n de la arquitectura modular:**
La aplicaci√≥n est√° organizada en m√≥dulos independientes que se encargan de diferentes tareas. El frontend gestiona la interacci√≥n con el usuario, la carga de archivos y la visualizaci√≥n de resultados. El backend realiza el procesamiento de datos, filtrado, c√°lculos espectrales y generaci√≥n de gr√°ficos. El sistema de cach√© optimiza el rendimiento evitando rec√°lculos innecesarios, y las utilidades proporcionan funciones de validaci√≥n, manejo de errores y optimizaci√≥n de datasets. Esta estructura facilita el mantenimiento, la escalabilidad y la incorporaci√≥n de nuevas funcionalidades.

```
RD_V1.10.3.py
‚îú‚îÄ‚îÄ üé® Frontend (Dash Layout)
‚îÇ   ‚îú‚îÄ‚îÄ Carga de archivos
‚îÇ   ‚îú‚îÄ‚îÄ Controles de filtros
‚îÇ   ‚îú‚îÄ‚îÄ Par√°metros de ensayo
‚îÇ   ‚îú‚îÄ‚îÄ Visualizaci√≥n de gr√°ficos
‚îÇ   ‚îî‚îÄ‚îÄ Exportaci√≥n de datos
‚îÇ
‚îú‚îÄ‚îÄ üß† Backend (Procesamiento)
‚îÇ   ‚îú‚îÄ‚îÄ Carga y validaci√≥n de datos
‚îÇ   ‚îú‚îÄ‚îÄ Filtrado de se√±ales
‚îÇ   ‚îú‚îÄ‚îÄ C√°lculos de FFT y FRF
‚îÇ   ‚îú‚îÄ‚îÄ An√°lisis de amortiguamiento
‚îÇ   ‚îî‚îÄ‚îÄ Generaci√≥n de gr√°ficos
‚îÇ
‚îú‚îÄ‚îÄ üíæ Sistema de Cach√©
‚îÇ   ‚îú‚îÄ‚îÄ Cache computacional LRU
‚îÇ   ‚îú‚îÄ‚îÄ Hashing de par√°metros
‚îÇ   ‚îú‚îÄ‚îÄ Invalidaci√≥n inteligente
‚îÇ   ‚îî‚îÄ‚îÄ Optimizaci√≥n autom√°tica
‚îÇ
‚îî‚îÄ‚îÄ üîß Utilidades
    ‚îú‚îÄ‚îÄ Optimizaci√≥n de datasets
    ‚îú‚îÄ‚îÄ Validaci√≥n de datos
    ‚îú‚îÄ‚îÄ Manejo de errores
    ‚îî‚îÄ‚îÄ Logging y debug
```

### üîÑ **Flujo de Datos**

```
üìÅ Archivo ‚Üí üîç Detecci√≥n ‚Üí ‚úÖ Validaci√≥n ‚Üí üìä DataFrame
    ‚Üì
üéõÔ∏è Filtros ‚Üí üîß Procesamiento ‚Üí üìà An√°lisis
    ‚Üì
‚ö° FFT ‚Üí üìä FRF ‚Üí üßÆ Rigidez ‚Üí üìã Amortiguamiento
    ‚Üì
üé® Visualizaci√≥n ‚Üí üíæ Cach√© ‚Üí üì• Exportaci√≥n
```

---

## üíæ SISTEMA DE CACH√â INTELIGENTE

**¬øPor qu√© es importante el sistema de cach√©?**
El sistema de cach√© permite que los c√°lculos m√°s pesados, como la FFT, el an√°lisis waterfall y la FRF, se realicen solo una vez por cada conjunto de par√°metros. Si el usuario repite una operaci√≥n con los mismos datos y par√°metros, el resultado se recupera instant√°neamente, acelerando el flujo de trabajo y evitando esperas innecesarias. Esto es especialmente √∫til en datasets grandes, donde los c√°lculos pueden tardar varios segundos o minutos.

**¬øC√≥mo funciona la pol√≠tica LRU?**
La pol√≠tica LRU (Least Recently Used) elimina autom√°ticamente los resultados menos utilizados cuando la memoria del cach√© alcanza su l√≠mite. As√≠, se garantiza que los resultados m√°s relevantes y recientes est√©n siempre disponibles, optimizando el uso de recursos y evitando saturaciones de memoria.

**¬øQu√© ventajas aporta al usuario?**
- Permite iterar r√°pidamente sobre diferentes par√°metros de an√°lisis sin rec√°lculos.
- Reduce el tiempo de espera al cambiar escalas, filtros o ventanas temporales.
- Facilita la comparaci√≥n de resultados y la validaci√≥n experimental.

### üéØ **Objetivo**
Optimizar el rendimiento evitando rec√°lculos innecesarios de FFT, waterfall y FRF cuando los par√°metros no han cambiado.

### üß† **Arquitectura del Cach√©**

```python
class CacheComputacional:
    """
    Sistema LRU con hashing inteligente de par√°metros
    """
    def __init__(self, max_cache_size=50):
        self.cache = {}                 # Resultados almacenados
        self.cache_access_times = {}    # Timestamps LRU
        self.max_cache_size = 50        # L√≠mite de memoria
        self.hits = 0                   # Estad√≠sticas de hit
        self.misses = 0                 # Estad√≠sticas de miss
```

### ‚ö° **Beneficios de Rendimiento**

|        Operaci√≥n         | Sin Cach√© | Con Cach√© |    Mejora   |
|--------------------------|-----------|-----------|-------------|
| **Cambio de escala FFT** |  2-5 seg  | < 0.1 seg |  **95%** ‚ö° |
|    **Cambio vista 3D**   |  3-8 seg  | < 0.2 seg |  **95%** ‚ö° |
| **Switch entre se√±ales** |  1-3 seg  | < 0.1 seg |  **90%** ‚ö° |
|  **Rec√°lculo waterfall** |  5-15 seg | < 0.3 seg |  **95%** ‚ö° |

### üîÑ **Funcionamiento Autom√°tico**

#### **1. Activaci√≥n por Defecto**
```python
USAR_CACHE = True  # ‚úÖ HABILITADO autom√°ticamente
```

#### **2. Limpieza Inteligente**
- **Al iniciar aplicaci√≥n**: Cach√© vac√≠o
- **Al cargar nuevo archivo**: Limpieza autom√°tica
- **Al aplicar filtros/cortes**: Invalidaci√≥n por cambio de datos
- **Memoria llena**: Eliminaci√≥n LRU autom√°tica

#### **3. Detecci√≥n de Cambios**
```python
# Hash inteligente de par√°metros
def generar_hash_parametros(self, *args, **kwargs):
    parametros_str = f"{args}_{sorted(kwargs.items())}"
    return hashlib.md5(parametros_str.encode()).hexdigest()
```

#### **4. Funciones Adaptativas**
```python
def generar_grafico_fft_adaptativo(df, seleccion_multi, escala_x, escala_y):
    if USAR_CACHE:
        return generar_grafico_fft_con_cache(...)  # üöÄ Optimizado
    else:
        return generar_grafico_fft_optimizado(...) # üîß Original
```

### üìä **Monitoreo en Tiempo Real**
```bash
[CACHE] FFT obtenida del cach√© (hit rate: 85.3%)
[CACHE] Waterfall obtenido del cach√© (hit rate: 78.9%)
[CACH√â] Cach√© limpiado al cargar nuevo archivo
```

---

## üîß FUNCIONALIDADES DETALLADAS

**Explicaci√≥n de cada funcionalidad:**
- **Carga de archivos inteligente**: Detecta autom√°ticamente el formato y la estructura de los datos, evitando errores comunes y facilitando el trabajo con diferentes sistemas de adquisici√≥n. La validaci√≥n robusta asegura que los datos sean consistentes y aptos para el an√°lisis.
- **Sistema de filtros avanzado**: Permite limpiar las se√±ales de ruido, offset y componentes no deseadas, mejorando la calidad del an√°lisis espectral y modal. Cada filtro est√° dise√±ado para preservar las caracter√≠sticas relevantes de la se√±al.
- **An√°lisis espectral robusto**: Utiliza ventaneo adaptativo y algoritmos optimizados para obtener resultados precisos incluso en presencia de ruido o transitorios. El c√°lculo eficiente de la FFT y la FRF permite trabajar con grandes vol√∫menes de datos sin perder resoluci√≥n.
- **An√°lisis waterfall 3D**: Segmenta la se√±al en ventanas temporales y calcula la FFT de cada segmento, mostrando c√≥mo evolucionan los modos de vibraci√≥n a lo largo del tiempo. La segmentaci√≥n adaptativa optimiza el rendimiento y la visualizaci√≥n.
- **C√°lculo de rigidez din√°mica**: Emplea estimadores robustos y detecci√≥n autom√°tica de antiresonancias para obtener resultados fiables y f√≠sicamente consistentes. La validaci√≥n de coherencia y el manejo de zonas problem√°ticas aseguran la calidad del an√°lisis.
- **An√°lisis de amortiguamiento**: Calcula tanto el amortiguamiento modal (por ancho de banda) como el global (por decremento logar√≠tmico), proporcionando informaci√≥n detallada sobre la disipaci√≥n de energ√≠a en la estructura.

### üìÅ **Carga de Archivos Inteligente**

#### **Detecci√≥n Autom√°tica de Formato**
```python
def cargar_archivo(contents, filename):
    # 1. Detectar extensi√≥n (.csv, .txt, .xlsx)
    # 2. Autodetectar separador (coma, punto y coma, tabulador)
    # 3. Identificar l√≠nea de cabeceras
    # 4. Validar estructura de datos
    # 5. Normalizar columnas a est√°ndar
```

#### **Formatos Soportados**
- **CSV est√°ndar**: `,` o `;` como separador
- **TXT Catman**: Formato HBM con metadatos
- **XLSX**: Excel con autodetecci√≥n de hojas
- **Separadores mixtos**: Detecci√≥n inteligente

#### **Validaci√≥n Robusta**
- ‚úÖ Verificaci√≥n de columnas requeridas
- ‚úÖ Conversi√≥n autom√°tica de tipos de datos
- ‚úÖ Eliminaci√≥n de filas problem√°ticas
- ‚úÖ Regeneraci√≥n de vector temporal si es irregular

### üéõÔ∏è **Sistema de Filtros Avanzado**

#### **1. Filtro Mediana Adaptativo**
```python
def aplicar_filtro_mediana(se√±al, kernel_size=5):
    """
    Elimina ruido impulsivo preservando transitorios
    """
    return medfilt(se√±al, kernel_size=kernel_size)
```

#### **2. Filtro Paso Alto**
```python
def aplicar_paso_alto(se√±al, frecuencia_corte, fs):
    """
    Elimina offset y deriva de baja frecuencia
    """
    b, a = butter(2, frecuencia_corte / (fs / 2), btype='high')
    return filtfilt(b, a, se√±al)
```

#### **3. Filtro Multibanda Inteligente**
```python
def filtro_multibanda_adaptativo(se√±al, fs, frecuencias_centrales, ancho_banda=20.0):
    """
    A√≠sla bandas espec√≠ficas con agrupamiento autom√°tico
    """
    # 1. Agrupar frecuencias cercanas
    # 2. Calcular bandas √≥ptimas
    # 3. Dise√±ar filtro FIR
    # 4. Aplicar con validaci√≥n de p√©rdidas
```

#### **Caracter√≠sticas del Filtro Multibanda**
- **Agrupamiento autom√°tico** de frecuencias cercanas
- **Validaci√≥n de p√©rdidas** de amplitud
- **Optimizaci√≥n iterativa** del orden FIR
- **Preservaci√≥n de fases** importantes

### üìä **An√°lisis Espectral Robusto**

#### **FFT con Ventaneo Adaptativo**
```python
def ventana_exponencial(y, fs, tau=None):
    """
    Ventaneo optimizado para an√°lisis transitorio
    """
    # 1. Estimar tau autom√°ticamente
    # 2. Detectar decaimiento al 5%
    # 3. Aplicar ventana exponencial
    # 4. Preservar caracter√≠sticas espectrales
```

#### **Ventaneo Espec√≠fico por Tipo de Se√±al**
- **Aceleraci√≥n**: Ventana exponencial adaptativa
- **Fuerza**: Ventana de impacto con detecci√≥n autom√°tica
- **Otros**: Ventaneo Hann est√°ndar

#### **FFT Optimizada**
- **C√°lculo eficiente** con scipy
- **Manejo de datasets grandes** (>100k puntos)
- **Escalas logar√≠tmicas/lineales**
- **Conversi√≥n autom√°tica** a dB

### üåä **An√°lisis Waterfall 3D**

#### **Segmentaci√≥n Adaptativa**
```python
def generar_waterfall_optimizado(df_json, seleccion_eje, ...):
    # Optimizaci√≥n autom√°tica seg√∫n tama√±o
    if N > 200000:
        max_segments = 20      # Dataset muy grande
    elif N > 100000:
        max_segments = 30      # Dataset mediano
    else:
        max_segments = 50      # Dataset peque√±o
```

#### **Caracter√≠sticas Avanzadas**
- **Duraci√≥n de segmento configurable**
- **Solapamiento optimizado** (50%)
- **Reducci√≥n visual inteligente** para performance
- **Vista 3D con controles** de c√°mara
- **√ânfasis selectivo** de curvas

### üìà **An√°lisis de Rigidez Din√°mica**

#### **C√°lculo de FRF Robusta**
```python
def calculate_dynamic_stiffness_robust(H_frf, frequencies):
    """
    K(œâ) = -œâ¬≤ / H(œâ)
    """
    # 1. Detectar antiresonancias
    # 2. Calcular rigidez din√°mica
    # 3. Interpolar zonas problem√°ticas
    # 4. Validar resultados f√≠sicos
```

#### **Estimadores de FRF**
- **H1**: `S_xf / S_ff` (ruido en salida)
- **H2**: `S_xx / S_xf*` (ruido en entrada)
- **Hv**: Combinaci√≥n ponderada por coherencia

#### **Detecci√≥n de Antiresonancias**
```python
def detect_antiresonances(H_frf, frequencies, window_hz=10):
    # 1. Calcular piso de ruido local
    # 2. Identificar ca√≠das significativas
    # 3. Validar con coherencia
    # 4. Marcar para interpolaci√≥n
```

### üîä **An√°lisis de Amortiguamiento**

#### **Amortiguamiento Modal (Ancho de Banda)**
```python
def calculo_amortiguamiento(accel, fs, frecuencias_centrales=None):
    """
    Œ∂ = (f‚ÇÇ - f‚ÇÅ) / (2 √ó f‚Çô)
    """
    # 1. Detectar picos espectrales
    # 2. Calcular ancho de banda -3dB
    # 3. Estimar amortiguamiento modal
    # 4. Validar rango f√≠sico
```

#### **Amortiguamiento Global (Decremento Logar√≠tmico)**
```python
def damping_least_squares(signal, fs):
    """
    Œ∂ = -slope / œâ
    """
    # 1. Detectar picos temporales
    # 2. Ajuste por m√≠nimos cuadrados
    # 3. Calcular pendiente de decaimiento
    # 4. Convertir a factor de amortiguamiento
```

---

## üé® INTERFAZ DE USUARIO

**Explicaci√≥n de cada secci√≥n de la interfaz:**
- **Carga de archivo**: Permite al usuario seleccionar y cargar datos experimentales en diferentes formatos. El estado visual indica si la carga fue exitosa y si los datos est√°n listos para el an√°lisis.
- **Par√°metros del ensayo**: El usuario puede configurar par√°metros clave como la masa del martillo, que afectan directamente el c√°lculo de la FRF y la rigidez din√°mica. Los estados visuales ayudan a evitar errores y asegurar que los valores sean aplicados correctamente.
- **Filtros de se√±al**: Ofrece controles para activar y ajustar los filtros digitales, permitiendo limpiar la se√±al antes del an√°lisis espectral y modal. La interfaz muestra el estado de cada filtro y su efecto sobre los datos.
- **Corte temporal**: Permite seleccionar la ventana de tiempo relevante para el an√°lisis, excluyendo zonas ruidosas o irrelevantes. El estado visual informa sobre la cantidad de datos seleccionados y la efectividad del corte.
- **Selecci√≥n de se√±ales**: El usuario puede elegir qu√© se√±ales analizar y visualizar, facilitando la comparaci√≥n entre diferentes ejes de aceleraci√≥n y la fuerza. Los controles permiten alternar entre gr√°ficos temporales, espectrales y 3D.
- **Sistema de indicadores de estado**: Utiliza colores e iconos para informar al usuario sobre el estado de cada acci√≥n, facilitando la interpretaci√≥n y evitando errores.

### üéõÔ∏è **Panel de Control Principal**

#### **Secci√≥n 1: Carga de Archivo**
```html
üìÅ Cargar archivo CSV de datos: [Seleccionar archivo]
üíæ Estado: "Archivo cargado: datos_ensayo.csv"
‚è≥ Loading: Indicador circular verde
```

#### **Secci√≥n 2: Par√°metros del Ensayo**
```html
üî® Masa martillo: [1.0] kg [Aplicar masa]
   ‚úì Estado visual: Verde = aplicado, Azul = listo, Gris = sin datos
```

#### **Secci√≥n 3: Filtros de Se√±al**
```html
üîß Mediana: ‚ö™ S√≠ ‚ö™ No [5]
üîä Paso alto: ‚ö™ S√≠ ‚ö™ No [0.5] Hz  
üìä Multibanda: ‚ö™ S√≠ ‚ö™ No [50,200] Hz
   [Aplicar filtros] ‚úì
```

#### **Secci√≥n 4: Corte Temporal**
```html
‚úÇÔ∏è Inicio (s): [____] Fin (s): [____] [Aplicar corte]
   ‚ö†Ô∏è "Corte aplicado: 0.5s a 2.0s, 15,000 puntos"
```

#### **Secci√≥n 5: Selecci√≥n de Se√±ales**
```html
üìä Tiempo/FFT:     üìà 3D/Rigidez:
‚òëÔ∏è Accel X         ‚ö™ Accel X
‚òê Accel Y         ‚ö™ Accel Y  
‚òê Accel Z         ‚ö™ Accel Z
‚òê Fuerza          ‚ö™ Fuerza
```

### üéÆ **Sistema de Indicadores de Estado**

#### **C√≥digo de Colores**
|      Color       |   Estado   |            Significado           |         Duraci√≥n       |
|------------------|------------|----------------------------------|------------------------|
|   üî¥ **Rojo**   | Bloqueado  |  No disponible por restricciones |       Persistente      |
| üü° **Amarillo** | Procesando |    ‚è≥ Trabajando en segundo plano | Durante procesamiento |
|   üü¢ **Verde**  | Completado | ‚úÖ Acci√≥n realizada exitosamente |       Persistente     |
|   üîµ **Azul**   | Disponible |   ‚óØ Listo para ejecutar acci√≥n   |       Hasta click     |
|   üîò **Gris**   | Sin datos  |   ‚ö†Ô∏è Falta informaci√≥n o datos   |     Hasta resolver     |

#### **Iconos de Estado**
- `‚ö†Ô∏è` Advertencia / sin datos
- `‚è≥` Procesando en tiempo real
- `‚úì` Completado exitosamente
- `‚óØ` Disponible para usar
- `‚óã` Configuraci√≥n incompleta
- `‚úó` Bloqueado por restricciones

### üìä **Gr√°ficos Interactivos**

#### **1. Gr√°fico Temporal**
- **M√∫ltiples se√±ales** superpuestas
- **Se√±al original vs filtrada** (l√≠nea punteada)
- **Zoom y pan** interactivos
- **Exportaci√≥n** a imagen

#### **2. Gr√°fico FFT**
- **Escalas X**: Linear/Logar√≠tmica
- **Escalas Y**: Amplitud/dB
- **Cambio instant√°neo** (con cach√©)
- **M√∫ltiples se√±ales** simult√°neas

#### **3. Gr√°fico Waterfall 3D**
- **Vista 3D rotable**
- **Selector de curvas** espec√≠ficas
- **√ânfasis visual** de curvas seleccionadas
- **Fijar vista** para comparaciones
- **Duraci√≥n de segmento** configurable

#### **4. Gr√°fico Rigidez Din√°mica**
- **Magnitud y fase** en subplots
- **Escalas configurables**
- **Detecci√≥n autom√°tica** de resonancias
- **Indicador de estimador** usado (H1/H2/Hv)

#### **5. Gr√°fico Coherencia**
- **Validaci√≥n de FRF**
- **Rango 0-1** fijo
- **Identificaci√≥n** de frecuencias fiables

---

## üßÆ ALGORITMOS Y M√âTODOS

**Explicaci√≥n de los algoritmos principales:**
- **Funci√≥n de respuesta en frecuencia (FRF)**: Permite relacionar la excitaci√≥n y la respuesta de la estructura en el dominio de la frecuencia, siendo la base para el c√°lculo de la rigidez din√°mica y el amortiguamiento.
- **Rigidez din√°mica**: Indica la resistencia de la estructura a la deformaci√≥n bajo cargas din√°micas. El c√°lculo robusto maneja antiresonancias y valida los resultados f√≠sicos para evitar errores experimentales.
- **Estimadores robustos (H1, H2, Hv)**: Cada estimador est√° dise√±ado para minimizar el efecto del ruido en diferentes situaciones experimentales. La combinaci√≥n ponderada por coherencia asegura que se utilice el estimador m√°s adecuado en cada rango de frecuencia.
- **Coherencia**: Mide la calidad de la medici√≥n y ayuda a identificar rangos de frecuencia donde los resultados son fiables. La validaci√≥n autom√°tica informa al usuario si la configuraci√≥n experimental necesita ajustes.
- **Algoritmos de amortiguamiento**: Calculan tanto el amortiguamiento modal (por ancho de banda) como el global (por decremento logar√≠tmico), proporcionando informaci√≥n sobre la disipaci√≥n de energ√≠a y la estabilidad de la estructura.

### üìê **Base Matem√°tica**

**¬øPor qu√© son importantes estas f√≥rmulas?**
Las f√≥rmulas matem√°ticas presentadas aqu√≠ son la base del an√°lisis de rigidez din√°mica y amortiguamiento. Permiten transformar los datos experimentales en informaci√≥n √∫til para el diagn√≥stico y dise√±o estructural. Cada expresi√≥n tiene un prop√≥sito espec√≠fico y su correcta interpretaci√≥n es clave para obtener resultados fiables.

**Interpretaci√≥n de cada f√≥rmula:**

#### **Funci√≥n de Respuesta en Frecuencia (FRF)**
```
H(œâ) = X(œâ) / F(œâ)
```
Donde:
- `X(œâ)`: Respuesta en frecuencia (aceleraci√≥n)
- `F(œâ)`: Excitaci√≥n en frecuencia (fuerza)

Esta f√≥rmula expresa c√≥mo responde la estructura (aceleraci√≥n) ante una fuerza aplicada en cada frecuencia. Es fundamental para caracterizar el comportamiento din√°mico y sirve como base para el c√°lculo de la rigidez y el amortiguamiento. Un valor alto de H(œâ) indica que la estructura responde fuertemente a esa frecuencia, lo que puede se√±alar una resonancia.

#### **Rigidez Din√°mica**
```
K(œâ) = -œâ¬≤ / H(œâ)
```
Para sistemas con entrada fuerza y salida aceleraci√≥n.

La rigidez din√°mica K(œâ) indica cu√°nta fuerza se requiere para producir una aceleraci√≥n determinada en cada frecuencia. Valores bajos de K(œâ) suelen coincidir con resonancias (la estructura se mueve mucho con poca fuerza), mientras que valores altos pueden se√±alar zonas r√≠gidas o antiresonancias. El signo negativo refleja la relaci√≥n f√≠sica entre fuerza y aceleraci√≥n en sistemas vibratorios.

#### **Estimadores Robustos**
```python
# H1 - √ìptimo para ruido en salida
H1(œâ) = S_xf(œâ) / S_ff(œâ)

# H2 - √ìptimo para ruido en entrada  
H2(œâ) = S_xx(œâ) / S_xf*(œâ)

# Hv - Combinaci√≥n ponderada por coherencia
Hv(œâ) = H1 si Œ≥¬≤ > 0.9
      = ‚àö(H1√óH2) si 0.7 < Œ≥¬≤ ‚â§ 0.9  
      = H2 si Œ≥¬≤ ‚â§ 0.7
```

Estos estimadores permiten calcular la FRF de manera robusta, minimizando el efecto del ruido seg√∫n su origen (entrada o salida). H1 es ideal cuando el ruido afecta principalmente la aceleraci√≥n, H2 cuando afecta la fuerza, y Hv combina ambos seg√∫n la coherencia, asegurando que se utilice el estimador m√°s fiable en cada rango de frecuencia. Esto mejora la calidad y la interpretaci√≥n de los resultados experimentales.

#### **Coherencia**
```
Œ≥¬≤(œâ) = |S_xf(œâ)|¬≤ / (S_xx(œâ) √ó S_ff(œâ))
```

La coherencia Œ≥¬≤(œâ) mide la calidad de la relaci√≥n entre fuerza y aceleraci√≥n en cada frecuencia. Valores cercanos a 1 indican que la medici√≥n es fiable y que el ruido es bajo; valores bajos sugieren problemas experimentales, como ruido excesivo, mala sincronizaci√≥n o errores en los sensores. Es fundamental revisar la coherencia antes de interpretar los resultados de rigidez y amortiguamiento.

### üî¢ **Algoritmos de Amortiguamiento**

El amortiguamiento es una propiedad clave para entender c√≥mo una estructura disipa energ√≠a y c√≥mo responde ante vibraciones. Los algoritmos presentados aqu√≠ permiten calcular tanto el amortiguamiento modal (asociado a cada modo de vibraci√≥n) como el global (de toda la estructura), proporcionando informaci√≥n esencial para el dise√±o y diagn√≥stico.

#### **M√©todo Ancho de Banda (-3dB)**
```python
def amortiguamiento_modal(pico_frecuencia, f1, f2):
    """
    f1, f2: Frecuencias a -3dB del pico
    fn: Frecuencia natural del pico
    """
    zeta = (f2 - f1) / (2 * fn)
    return zeta
```

Este m√©todo estima el amortiguamiento modal a partir del ancho de banda de cada pico espectral. Se identifican las frecuencias a -3dB del m√°ximo y se calcula el factor de amortiguamiento. Valores t√≠picos para estructuras met√°licas oscilan entre 0.01 y 0.05. Un ancho de banda mayor indica mayor disipaci√≥n de energ√≠a.

#### **Decremento Logar√≠tmico**
```python
def decremento_logaritmico(signal_temporal, fs):
    """
    Œ¥ = ln(x_n / x_{n+1})
    Œ∂ = Œ¥ / ‚àö(4œÄ¬≤ + Œ¥¬≤)
    """
    # 1. Detectar picos consecutivos
    # 2. Calcular decremento logar√≠tmico
    # 3. Convertir a factor de amortiguamiento
```

El decremento logar√≠tmico calcula el amortiguamiento global a partir de la ca√≠da de los picos en la se√±al temporal. Es √∫til para respuestas impulsivas y permite estimar la disipaci√≥n de energ√≠a en todo el sistema. Valores negativos o superiores a 0.5 suelen indicar errores de medici√≥n o problemas experimentales.

### üî¨ **Validaciones Cient√≠ficas**

Las validaciones cient√≠ficas aseguran que los resultados obtenidos sean f√≠sicamente razonables y fiables. Cada funci√≥n verifica rangos, detecta problemas experimentales y ayuda al usuario a interpretar correctamente los resultados, evitando conclusiones err√≥neas.

#### **Validaci√≥n de Coherencia**
```python
def validar_coherencia(coherencia, umbral=0.8):
    """
    Coherencia > 0.8: Excelente
    Coherencia > 0.6: Buena  
    Coherencia < 0.6: Revisar medida
    """
```

Esta funci√≥n clasifica la calidad de la medici√≥n seg√∫n la coherencia. Si Œ≥¬≤ > 0.8, los resultados son altamente fiables; entre 0.6 y 0.8, son aceptables pero requieren precauci√≥n; por debajo de 0.6, se recomienda revisar la configuraci√≥n experimental, aplicar filtros o repetir el ensayo.

#### **Detecci√≥n de Antiresonancias**
```python
def es_antiresonancia(H_magnitude, threshold_db=-25):
    """
    Detecta ca√≠das significativas en la FRF
    que pueden afectar el c√°lculo de rigidez
    """
```

Las antiresonancias son zonas donde la magnitud de la FRF cae abruptamente, lo que puede distorsionar el c√°lculo de la rigidez din√°mica. Detectarlas permite interpolar o corregir los resultados, asegurando que la interpretaci√≥n f√≠sica sea v√°lida y evitando errores en el diagn√≥stico estructural.

#### **Rango F√≠sico de Amortiguamiento**
```python
def validar_amortiguamiento(zeta):
    """
    0 < Œ∂ < 0.5: F√≠sicamente razonable
    Œ∂ > 0.5: Sobreamortiguado (verificar)
    Œ∂ < 0: Error de c√°lculo
    """
```

Esta funci√≥n verifica que el valor de amortiguamiento calculado sea f√≠sicamente posible. Valores entre 0 y 0.5 son t√≠picos en estructuras reales; valores superiores a 0.5 indican sobreamortiguamiento y deben ser revisados; valores negativos se√±alan errores de c√°lculo o problemas en la medici√≥n.

---

## ‚ö° OPTIMIZACIONES DE RENDIMIENTO

### üöÄ **Optimizaciones Autom√°ticas**

#### **1. Datasets Grandes (>50k puntos)**
```python
def optimizar_dataframe_para_visualizacion(df, max_puntos=50000):
    """
    Submuestreo inteligente para visualizaci√≥n:
    - 30% en primer 10% del tiempo (impactos)
    - 70% distribuido uniformemente
    """
```

#### **2. FFT Optimizada**
```python
def generar_grafico_fft_optimizado(df, ...):
    # Para datasets >100k puntos
    if len(df) > 100000:
        max_fft_points = 32768  # L√≠mite √≥ptimo
        mostrar_progreso_simple("FFT optimizada", len(df))
```

#### **3. Waterfall Adaptativo**
```python
def generar_waterfall_optimizado(df_json, ...):
    # Optimizaci√≥n autom√°tica por tama√±o
    if N > 200000:
        max_segments = 20      # Muy grande
    elif N > 100000:  
        max_segments = 30      # Mediano
    else:
        max_segments = 50      # Peque√±o
```

### üìä **M√©tricas de Rendimiento**

|         Operaci√≥n         |  Dataset Peque√±o (<50k) | Dataset Grande (>200k) |      Optimizaci√≥n     |
|---------------------------|-------------------------|------------------------|-----------------------|
|     **Carga archivo**     |         < 1 seg         |         2-5 seg        |  Validaci√≥n eficiente |
|     **FFT sin cach√©**     |         1-2 seg         |         5-15 seg       |   Limitaci√≥n puntos   |
|     **FFT con cach√©**     |        < 0.1 seg        |        < 0.1 seg       |   ‚ö°**95% mejora**    |
|  **Waterfall sin cach√©**  |         3-5 seg         |        15-30 seg       | Segmentos adaptativos |
|  **Waterfall con cach√©**  |        < 0.2 seg        |        < 0.3 seg       |   ‚ö°**90% mejora**    |
|     **Cambio escala**     |        0.5-1 seg        |         2-5 seg        |  Regeneraci√≥n parcial |
| **Cambio escala (cach√©)** |        < 0.1 seg        |        < 0.1 seg       |   ‚ö° **95% mejora**   |

### üß† **Estrategias de Memoria**

#### **Gesti√≥n Inteligente de Memoria**
```python
def monitorear_memoria():
    """
    Controla uso de RAM y aplica limpieza preventiva
    """
    memoria_actual = psutil.Process().memory_info().rss / (1024**2)
    if memoria_actual > 2000:  # >2GB
        gc.collect()  # Forzar limpieza
```

#### **Pol√≠tica LRU en Cach√©**
```python
def cache_lru_eviction(self):
    """
    Elimina elementos menos recientemente usados
    cuando se alcanza el l√≠mite de memoria
    """
    if len(self.cache) >= self.max_cache_size:
        oldest_key = min(self.cache_access_times.keys(), 
                        key=lambda k: self.cache_access_times[k])
        del self.cache[oldest_key]
```

---

## üíª GU√çA DE INSTALACI√ìN

### üìã **Requisitos del Sistema**

#### **Requisitos M√≠nimos**
- **SO**: Windows 10/11, macOS 10.14+, Linux Ubuntu 18.04+
- **Python**: 3.8 o superior
- **RAM**: 4 GB m√≠nimo (8 GB recomendado)
- **Espacio disco**: 500 MB para instalaci√≥n
- **Navegador**: Chrome, Firefox, Safari, Edge (versiones recientes)

#### **Requisitos Recomendados**
- **RAM**: 16 GB (para datasets grandes >1M puntos)
- **CPU**: 4 n√∫cleos o m√°s para procesamiento paralelo
- **SSD**: Para mejor rendimiento de carga de archivos

### üêç **Instalaci√≥n Python**

#### **1. Verificar Python**
```bash
python --version
# Debe mostrar Python 3.8+ 
```

#### **2. Crear Entorno Virtual (Recomendado)**
```bash
# Crear entorno
python -m venv rigidez_dinamica_env

# Activar entorno (Windows)
rigidez_dinamica_env\Scripts\activate

# Activar entorno (macOS/Linux)
source rigidez_dinamica_env/bin/activate
```

#### **3. Instalar Dependencias**
```bash
pip install dash==2.14.1
pip install plotly==5.17.0
pip install pandas==2.1.0
pip install numpy==1.24.3
pip install scipy==1.11.1
pip install dash-bootstrap-components==1.4.1
pip install openpyxl==3.1.2
pip install psutil==5.9.5
```

#### **Archivo requirements.txt**
```txt
dash==2.14.1
plotly==5.17.0  
pandas==2.1.0
numpy==1.24.3
scipy==1.11.1
dash-bootstrap-components==1.4.1
openpyxl==3.1.2
psutil==5.9.5
```

Instalar con:
```bash
pip install -r requirements.txt
```

### üìÅ **Estructura de Proyecto**

```
üìÅ rigidez_dinamica/
‚îú‚îÄ‚îÄ üìÑ RD_V1.10.3.py           # Aplicaci√≥n principal
‚îú‚îÄ‚îÄ üìÑ requirements.txt         # Dependencias Python
‚îú‚îÄ‚îÄ üìÅ assets/                 # Recursos est√°ticos
‚îÇ   ‚îî‚îÄ‚îÄ üñºÔ∏è logo_edai.png       # Logo de la aplicaci√≥n
‚îú‚îÄ‚îÄ üìÅ datos_prueba/           # Archivos de ejemplo
‚îÇ   ‚îú‚îÄ‚îÄ üìä ensayo_001.csv
‚îÇ   ‚îú‚îÄ‚îÄ üìä ensayo_catman.txt
‚îÇ   ‚îî‚îÄ‚îÄ üìä ensayo_excel.xlsx
‚îî‚îÄ‚îÄ üìÑ DOCUMENTACION_RIGIDEZ_DINAMICA.md  # Esta documentaci√≥n
```

### ‚ñ∂Ô∏è **Ejecutar Aplicaci√≥n**

#### **M√©todo 1: Ejecuci√≥n Directa**
```bash
python RD_V1.10.3.py
```

#### **M√©todo 2: Script de Inicio (Windows)**
```batch
@echo off
echo Iniciando aplicaci√≥n Rigidez Din√°mica...
cd /d "%~dp0"
call rigidez_dinamica_env\Scripts\activate
python RD_V1.10.3.py
pause
```

#### **M√©todo 3: Script de Inicio (Linux/macOS)**
```bash
#!/bin/bash
echo "Iniciando aplicaci√≥n Rigidez Din√°mica..."
cd "$(dirname "$0")"
source rigidez_dinamica_env/bin/activate
python RD_V1.10.3.py
```

### üåê **Acceso Web**

1. **Ejecutar script** de inicio
2. **Esperar mensaje**: "Running on http://127.0.0.1:8050"
3. **Navegador se abre autom√°ticamente** o ir a: http://localhost:8050
4. **Aplicaci√≥n lista** para usar

---

## üë®‚Äçüíª GU√çA DE USUARIO

### üöÄ **Inicio R√°pido**

#### **Paso 1: Cargar Datos**
1. Click en **"Seleccionar archivo"**
2. Elegir archivo (.csv, .txt, .xlsx)
3. **Verificar carga exitosa**: mensaje verde con nombre del archivo
4. **Validar datos**: gr√°fico temporal debe aparecer autom√°ticamente

#### **Paso 2: Configurar Par√°metros**
```html
üî® Masa martillo: [1.5] kg ‚Üí [Aplicar masa] ‚úÖ
   ‚ö†Ô∏è IMPORTANTE: Aplicar masa antes de continuar
```

#### **Paso 3: Aplicar Filtros (Opcional)**
```html
üîß Mediana: ‚úÖ S√≠ [5]           # Eliminar ruido impulsivo
üîä Paso alto: ‚úÖ S√≠ [0.5] Hz   # Eliminar offset  
üìä Multibanda: ‚úÖ S√≠ [50,200] Hz # Aislar frecuencias
   ‚Üí [Aplicar filtros] ‚úÖ
```

#### **Paso 4: Corte Temporal (Opcional)**
```html
‚úÇÔ∏è Inicio: [0.1] s  Fin: [2.0] s ‚Üí [Aplicar corte] ‚úÖ
   üí° TIP: Cortar zona de inter√©s para mejor an√°lisis
```

#### **Paso 5: Seleccionar Se√±ales**
```html
üìä Para gr√°ficos tiempo/FFT:    üìà Para an√°lisis 3D/rigidez:
‚òëÔ∏è Accel X                     ‚ö™ Accel X ‚Üê Seleccionado
‚òëÔ∏è Accel Y                     ‚ö™ Accel Y
‚òê Accel Z                      ‚ö™ Accel Z
‚òê Fuerza                       ‚ö™ Fuerza
```

### üìä **Interpretaci√≥n de Resultados**

#### **Gr√°fico Temporal**
- **Se√±al original** (l√≠nea punteada gris): Datos sin procesar
- **Se√±al filtrada** (l√≠nea s√≥lida color): Datos procesados
- **Validar**: Impacto claro al inicio, decaimiento exponencial

#### **Gr√°fico FFT**
- **Picos claros**: Frecuencias naturales del sistema
- **Escala dB**: Para mejor visualizaci√≥n de din√°micas amplias
- **Escala log**: Para analizar amplio rango frecuencial

#### **Gr√°fico Waterfall 3D**
- **Eje X**: Frecuencia (Hz)
- **Eje Y**: Tiempo (segmentos)
- **Eje Z**: Amplitud
- **Colores**: Intensidad de respuesta

#### **Rigidez Din√°mica**
- **Magnitud |K|**: Rigidez en N/mm
- **Fase ‚à†K**: Caracter√≠sticas din√°micas
- **Resonancias**: Ca√≠das en magnitud
- **Antiresonancias**: Picos en magnitud

#### **Coherencia**
- **Œ≥¬≤ > 0.8**: Excelente calidad de medida ‚úÖ
- **Œ≥¬≤ > 0.6**: Buena calidad ‚ö†Ô∏è
- **Œ≥¬≤ < 0.6**: Revisar configuraci√≥n experimental ‚ùå

#### **Tablas de Amortiguamiento**
```html
üìã Resumen Global:
   Œ∂ global: 0.0234 (2.34%)
   C/m: 15.678 N¬∑s/m

üìã Resumen Modal:
   Frecuencia: 85.3 Hz ‚Üí Œ∂: 0.0189 (1.89%)
   Frecuencia: 156.7 Hz ‚Üí Œ∂: 0.0267 (2.67%)
```

### üéÆ **Controles Avanzados**

#### **Controles de Vista 3D**
- **Restablecer visibilidad**: Mostrar todas las curvas
- **Fijar vista**: Bloquear orientaci√≥n de c√°mara
- **Selector de curvas**: Destacar curvas espec√≠ficas
- **Duraci√≥n segmento**: Controlar resoluci√≥n temporal

#### **Escalas de Visualizaci√≥n**
```html
üìê Eje X (FFT y 3D):
   ‚ö™ Lineal        ‚ö™ Logar√≠tmico

üìê Eje Y (Amplitud):  
   ‚ö™ Amplitud      ‚ö™ dB
```

#### **Exportaci√≥n de Datos**
- **Bot√≥n "Exportar datos 3D"**
- **Formato**: ZIP con 2 archivos CSV
  - `datos_3D_long.csv`: Formato largo (segmento, tiempo, freq, amplitud)
  - `datos_3D_matriz.csv`: Formato matricial (freq vs tiempo)

### üîß **Workflow T√≠pico**

#### **An√°lisis Est√°ndar**
```
1. üìÅ Cargar datos
2. üî® Configurar masa martillo  
3. üîß Aplicar filtros b√°sicos (mediana + paso alto)
4. üìä Revisar FFT para identificar modos
5. üìà Analizar rigidez din√°mica
6. üìã Extraer par√°metros de amortiguamiento
7. üíæ Exportar resultados
```

#### **An√°lisis Avanzado**
```
1. üìÅ Cargar datos
2. üî® Configurar masa martillo
3. üîß Aplicar filtro multibanda en frecuencias espec√≠ficas
4. ‚úÇÔ∏è Cortar ventana de inter√©s temporal
5. üåä Analizar waterfall 3D para evoluci√≥n temporal
6. üìä Comparar m√∫ltiples se√±ales (X, Y, Z)
7. üìà Evaluar coherencia para validar medidas
8. üìã Calcular amortiguamiento modal detallado
9. üíæ Exportar datos completos
```

---

## üîß TROUBLESHOOTING

**Explicaci√≥n de problemas comunes y soluciones:**
Cada error o s√≠ntoma descrito en esta secci√≥n incluye la causa probable y una soluci√≥n recomendada. El objetivo es que el usuario pueda identificar r√°pidamente el origen del problema y aplicar la correcci√≥n adecuada, evitando frustraciones y p√©rdidas de tiempo. Las soluciones est√°n pensadas para usuarios de todos los niveles, con instrucciones claras y pasos concretos.

### ‚ùå **Problemas Comunes**

#### **Error de Carga de Archivo**
```
‚ùå S√≠ntoma: "Error al leer el archivo: ..."
üîç Causas posibles:
   - Formato no soportado
   - Archivo corrupto
   - Codificaci√≥n incorrecta
   - Separadores inconsistentes

‚úÖ Soluciones:
   1. Verificar que el archivo es .csv, .txt o .xlsx
   2. Abrir en Excel y guardar como CSV UTF-8
   3. Verificar que hay al menos 5 columnas num√©ricas
   4. Revisar que la primera fila contiene headers v√°lidos
```

#### **Gr√°ficos Vac√≠os o Sin Datos**
```
‚ùå S√≠ntoma: Gr√°ficos muestran "Sin datos disponibles"
üîç Causas posibles:
   - Archivo sin datos v√°lidos
   - Columnas mal interpretadas
   - Datos todos NaN o infinitos
   - Selecci√≥n de se√±ales incorrecta

‚úÖ Soluciones:
   1. Revisar la carga: mensaje debe ser verde
   2. Verificar que las se√±ales est√°n seleccionadas
   3. Comprobar que las columnas tienen datos num√©ricos
   4. Reload p√°gina y volver a cargar archivo
```

#### **FFT/Waterfall Muy Lento**
```
‚ùå S√≠ntoma: C√°lculos tardan mucho tiempo
üîç Causas posibles:
   - Dataset muy grande (>1M puntos)
   - Cach√© deshabilitado
   - Memoria insuficiente
   - Filtros complejos aplicados

‚úÖ Soluciones:
   1. Verificar que USAR_CACHE = True
   2. Aplicar corte temporal para reducir datos
   3. Cerrar otras aplicaciones (liberar RAM)  
   4. Usar filtros simples primero
```

#### **Amortiguamiento No F√≠sico**
```
‚ùå S√≠ntoma: "Œ∂ = 0.8543" (>50%)
üîç Causas posibles:
   - Se√±al muy ruidosa
   - Excitaci√≥n insuficiente
   - M√∫ltiples modos superpuestos
   - Configuraci√≥n experimental incorrecta

‚úÖ Soluciones:
   1. Aplicar filtro mediana para reducir ruido
   2. Verificar la masa del martillo aplicada
   3. Usar filtro multibanda para aislar modos
   4. Revisar la coherencia (debe ser >0.8)
```

#### **Coherencia Baja**
```
‚ùå S√≠ntoma: Œ≥¬≤ < 0.6 en rangos de inter√©s
üîç Causas posibles:
   - Ruido excesivo en las se√±ales
   - Excitaci√≥n insuficiente
   - Problemas de sincronizaci√≥n
   - Distorsi√≥n en sensores

‚úÖ Soluciones:
   1. Aplicar filtros de ruido (mediana + paso alto)
   2. Verificar conexiones de sensores
   3. Revisar rango din√°mico de la adquisici√≥n
   4. Considerar ventaneo diferente
```

### üêõ **Errores T√©cnicos**

#### **Error: ImportError/ModuleNotFoundError**
```bash
‚ùå Error: "ImportError: No module named 'dash'"
‚úÖ Soluci√≥n:
   pip install dash plotly pandas numpy scipy
   
   # O usar requirements.txt:
   pip install -r requirements.txt
```

#### **Error: Memory/RAM Insuficiente**
```bash
‚ùå Error: "MemoryError" o aplicaci√≥n se cuelga
‚úÖ Soluciones:
   1. Cerrar otros programas
   2. Aplicar corte temporal antes de an√°lisis
   3. Usar datasets m√°s peque√±os para pruebas
   4. Aumentar memoria virtual del sistema
```

#### **Error: Puerto 8050 Ocupado**
```bash
‚ùå Error: "Address already in use: 8050"
‚úÖ Soluciones:
   1. Cerrar otra instancia de la aplicaci√≥n
   2. Esperar 30 segundos y reintentar
   3. Cambiar puerto en c√≥digo: app.run(port=8051)
   4. Reiniciar sistema si persiste
```

#### **Error: Permisos de Escritura**
```bash
‚ùå Error: "PermissionError" al exportar
‚úÖ Soluciones:
   1. Cerrar Excel si tiene archivos abiertos
   2. Ejecutar como administrador
   3. Cambiar directorio de trabajo
   4. Verificar permisos de carpeta
```

### üîç **Depuraci√≥n Avanzada**

#### **Activar Modo Debug**
```python
# En la l√≠nea final de RD_V1.10.3.py:
app.run(debug=True, dev_tools_hot_reload=False)
```

#### **Ver Logs de Cach√©**
```python
# En consola durante ejecuci√≥n:
stats = cache_computacional.estadisticas_cache()
print(f"Hit rate: {stats['hit_rate']:.1f}%")
print(f"Cache size: {stats['cache_size']} elementos")
```

#### **Verificar Datos de Entrada**
```python
# Despu√©s de cargar archivo, en consola:
[DEBUG] DataFrame cargado: shape=(50000, 5)
[DEBUG] Columnas: ['tiempo', 'fuerza', 'accel_x', 'accel_y', 'accel_z']
[DEBUG] Rango tiempo: 0.000 - 5.000 s
```

#### **Monitorear Memoria**
```python
# Agregar al c√≥digo para monitoreo:
import psutil
proceso = psutil.Process()
memoria_mb = proceso.memory_info().rss / (1024 * 1024)
print(f"Memoria usada: {memoria_mb:.1f} MB")
```

---

## üìñ API REFERENCE

**¬øC√≥mo aprovechar la API?**
La API permite a usuarios avanzados y desarrolladores integrar las funciones principales de la aplicaci√≥n en sus propios scripts o flujos de trabajo. Cada funci√≥n est√° documentada con ejemplos de uso, manejo de errores y validaci√≥n de datos. Se recomienda consultar la API para personalizar el an√°lisis, automatizar tareas o integrar la herramienta con otros sistemas.

**Explicaci√≥n de la API y ejemplos de uso:**
La API est√° dise√±ada para que los usuarios avanzados y desarrolladores puedan integrar las funciones principales de la aplicaci√≥n en sus propios scripts o flujos de trabajo. Cada funci√≥n incluye una descripci√≥n de los argumentos, el prop√≥sito, ejemplos de uso y notas sobre el manejo de errores y validaci√≥n de datos. Esto facilita la extensi√≥n y personalizaci√≥n de la herramienta para casos espec√≠ficos o integraciones con otros sistemas.

### üîß **Funciones Principales**

#### **cargar_archivo(contents, filename)**
```python
def cargar_archivo(contents, filename):
    """
    Carga y valida archivos CSV, TXT (Catman) o XLSX.
    
    Args:
        contents (str): Contenido codificado en base64
        filename (str): Nombre del archivo
        
    Returns:
        tuple: (mensaje_estado, df_json, mensaje_error)
        
    Raises:
        ValueError: Si el formato no es compatible
        
    Example:
        mensaje, datos, error = cargar_archivo(contents, "ensayo.csv")
    """
```

#### **filtrar_senal(df, seleccion_multi, seleccion_eje, fs, ...)**
```python
def filtrar_senal(df, seleccion_multi, seleccion_eje, fs, 
                  mediana_val, highpass_val, bandpass_multibanda, 
                  ancho_banda, toggle_mediana, toggle_highpass, toggle_bandpass):
    """
    Aplica filtros digitales a las se√±ales seleccionadas.
    
    Args:
        df (DataFrame): Datos de entrada
        seleccion_multi (list): Columnas a filtrar
        seleccion_eje (str): Eje principal para an√°lisis
        fs (float): Frecuencia de muestreo
        mediana_val (int): Kernel para filtro mediana
        highpass_val (float): Frecuencia de corte paso alto
        bandpass_multibanda (str): Frecuencias centrales separadas por coma
        ancho_banda (float): Ancho de banda para filtro multibanda
        toggle_* (str): Activaci√≥n de filtros ('yes'/'no')
        
    Returns:
        tuple: (df_filtrado, mensajes_filtro, frecuencias_centrales)
        
    Example:
        df_filt, msgs, freqs = filtrar_senal(df, ['accel_x'], 'accel_x', 
                                            1000, 5, 0.5, "50,200", 20,
                                            'yes', 'yes', 'yes')
    """
```

#### **generar_grafico_fft_adaptativo(df, seleccion_multi, escala_x, escala_y)**
```python
def generar_grafico_fft_adaptativo(df, seleccion_multi, escala_x, escala_y):
    """
    Genera gr√°fico FFT con cach√© autom√°tico si est√° habilitado.
    
    Args:
        df (DataFrame): Datos temporales
        seleccion_multi (list): Se√±ales a procesar
        escala_x (str): 'linear' o 'log'
        escala_y (str): 'amplitude' o 'db'
        
    Returns:
        plotly.Figure: Gr√°fico FFT interactivo
        
    Notes:
        - Usa cach√© autom√°ticamente si USAR_CACHE=True
        - Optimiza datasets grandes (>100k puntos)
        - Aplica ventaneo adaptativo por tipo de se√±al
        
    Example:
        fig = generar_grafico_fft_adaptativo(df, ['accel_x'], 'log', 'db')
    """
```

#### **generar_waterfall_adaptativo(df_json, seleccion_eje, ...)**
```python
def generar_waterfall_adaptativo(df_json, seleccion_eje, escala_x, escala_y,
                                curvas_enfasis, estado_fijar_vista, duracion_segmento):
    """
    Genera an√°lisis waterfall 3D con optimizaci√≥n autom√°tica.
    
    Args:
        df_json (str): DataFrame serializado en JSON
        seleccion_eje (str): Columna para an√°lisis ('accel_x', 'accel_y', etc.)
        escala_x (str): Escala frecuencial ('linear'/'log')
        escala_y (str): Escala amplitud ('amplitude'/'db')
        curvas_enfasis (list): √çndices de curvas a destacar
        estado_fijar_vista (bool): Fijar orientaci√≥n 3D
        duracion_segmento (float): Duraci√≥n de cada segmento (s)
        
    Returns:
        tuple: (figura_3d, datos_exportacion)
            - figura_3d: plotly.Figure con gr√°fico 3D
            - datos_exportacion: list de dict para exportar
            
    Notes:
        - Optimiza n√∫mero de segmentos seg√∫n tama√±o de datos
        - Usa cach√© para evitar rec√°lculos
        - Permite configuraci√≥n de duraci√≥n de ventana
        
    Example:
        fig, datos = generar_waterfall_adaptativo(df_json, 'accel_x', 
                                                 'log', 'db', [], False, 1.0)
    """
```

#### **calculo_amortiguamiento(accel, fs, frecuencias_centrales)**
```python
def calculo_amortiguamiento(accel, fs, frecuencias_centrales=None, ventana_busqueda_hz=5.0):
    """
    Calcula amortiguamiento modal y global.
    
    Args:
        accel (array): Se√±al de aceleraci√≥n
        fs (float): Frecuencia de muestreo
        frecuencias_centrales (list, optional): Frecuencias espec√≠ficas a analizar
        ventana_busqueda_hz (float): Ventana de b√∫squeda alrededor de freq centrales
        
    Returns:
        dict: Resultado con claves:
            - 'modos': Lista de dict con 'frecuencia' y 'zeta' 
            - 'zeta_global': Factor de amortiguamiento global
            - 'mensajes': Lista de advertencias/errores
            
    Methods:
        - Modal: Ancho de banda -3dB
        - Global: Decremento logar√≠tmico
        
    Example:
        resultado = calculo_amortiguamiento(accel_data, 1000.0, [50, 150])
        for modo in resultado['modos']:
            print(f"f={modo['frecuencia']:.1f} Hz, Œ∂={modo['zeta']:.4f}")
    """
```

### üíæ **Sistema de Cach√©**

#### **CacheComputacional**
```python
class CacheComputacional:
    """
    Sistema de cach√© LRU para optimizaci√≥n de c√°lculos.
    
    Attributes:
        cache (dict): Almac√©n de resultados
        cache_access_times (dict): Timestamps para LRU
        max_cache_size (int): L√≠mite de elementos (default: 50)
        hits (int): Contador de hits
        misses (int): Contador de misses
    """
    
    def generar_hash_parametros(self, *args, **kwargs):
        """Genera hash MD5 de par√°metros de entrada"""
        
    def obtener_de_cache(self, cache_key):
        """Recupera resultado si existe en cach√©"""
        
    def guardar_en_cache(self, cache_key, resultado):
        """Almacena resultado con pol√≠tica LRU"""
        
    def limpiar_cache(self):
        """Limpia todo el cach√© y estad√≠sticas"""
        
    def estadisticas_cache(self):
        """Retorna dict con hits, misses, hit_rate, cache_size"""
```

#### **Funciones de Control de Cach√©**
```python
def habilitar_cache():
    """Activa el sistema de cach√© globalmente"""
    
def deshabilitar_cache():
    """Desactiva y limpia el cach√©"""
    
def toggle_cache():
    """Alterna estado del cach√©"""
    
def limpiar_cache_si_necesario(forzar=False):
    """Limpia cach√© cuando es necesario o forzado"""
```

### üî¨ **Algoritmos Cient√≠ficos**

#### **Ventaneo Adaptativo**
```python
def ventana_exponencial(y, fs, tau=None):
    """
    Aplica ventana exponencial para an√°lisis transitorio.
    
    Args:
        y (array): Se√±al de entrada
        fs (float): Frecuencia de muestreo
        tau (float, optional): Constante de tiempo (auto si None)
        
    Returns:
        array: Se√±al ventaneada
        
    Notes:
        - Estima tau autom√°ticamente del decaimiento
        - Optimizado para respuestas impulsivas
    """

def ventana_fuerza_adaptativa(y, fs):
    """
    Ventana espec√≠fica para se√±ales de fuerza de impacto.
    
    Args:
        y (array): Se√±al de fuerza
        fs (float): Frecuencia de muestreo
        
    Returns:
        array: Se√±al ventaneada
        
    Notes:
        - Detecta duraci√≥n del impacto autom√°ticamente
        - Aplica tapering suave al final
    """
```

#### **An√°lisis de FRF**
```python
def calculate_H1(S_ff, S_xf):
    """Estimador H1: √≥ptimo para ruido en salida"""
    return S_xf / (S_ff + 1e-12)

def calculate_H2(S_xx, S_xf):
    """Estimador H2: √≥ptimo para ruido en entrada"""
    return S_xx / (np.conj(S_xf) + 1e-12)

def calculate_Hv(S_ff, S_xx, S_xf):
    """Estimador Hv: combinaci√≥n ponderada por coherencia"""
    H1 = calculate_H1(S_ff, S_xf)
    H2 = calculate_H2(S_xx, S_xf)
    coh = calculate_coherence(S_ff, S_xx, S_xf)
    return np.where(coh > 0.9, H1, 
           np.where(coh > 0.7, np.sqrt(H1 * H2), H2))

def calculate_coherence(S_ff, S_xx, S_xf):
    """Funci√≥n de coherencia"""
    return np.abs(S_xf)**2 / (S_ff * S_xx + 1e-12)
```

#### **Rigidez Din√°mica**
```python
def calculate_dynamic_stiffness_robust(H_frf, frequencies):
    """
    Calcula rigidez din√°mica con manejo robusto de antiresonancias.
    
    Args:
        H_frf (array): Funci√≥n de respuesta en frecuencia
        frequencies (array): Vector de frecuencias
        
    Returns:
        array: Rigidez din√°mica compleja K(œâ) = -œâ¬≤/H(œâ)
        
    Notes:
        - Detecta y maneja antiresonancias autom√°ticamente
        - Interpola zonas problem√°ticas
        - Valida resultados f√≠sicos
    """
```

### üé® **Optimizaci√≥n de Visualizaci√≥n**

#### **optimizar_dataframe_para_visualizacion(df, max_puntos)**
```python
def optimizar_dataframe_para_visualizacion(df, max_puntos=50000):
    """
    Reduce puntos para visualizaci√≥n sin p√©rdida de caracter√≠sticas.
    
    Args:
        df (DataFrame): Datos completos
        max_puntos (int): M√°ximo puntos para visualizaci√≥n
        
    Returns:
        tuple: (df_optimizado, fue_optimizado)
        
    Strategy:
        - 30% de puntos en primer 10% del tiempo (impactos)
        - 70% distribuido uniformemente en el resto
        - Preserva primer y √∫ltimo punto
    """
```

#### **mostrar_progreso_simple(mensaje, puntos_totales, puntos_finales)**
```python
def mostrar_progreso_simple(mensaje, puntos_totales, puntos_finales=None):
    """
    Muestra informaci√≥n de progreso en consola.
    
    Args:
        mensaje (str): Descripci√≥n de la operaci√≥n
        puntos_totales (int): Cantidad total de datos
        puntos_finales (int, optional): Cantidad despu√©s de optimizaci√≥n
        
    Output:
        [PROGRESO] FFT optimizada - Procesando 150,000 puntos
        [OPTIMIZACI√ìN] Waterfall 3D - 2,000,000 ‚Üí 500,000 puntos (75% reducci√≥n)
    """
```

### üîç **Utilidades de Validaci√≥n**

#### **validar_masa_martillo(masa)**
```python
def validar_masa_martillo(masa):
    """
    Valida rango f√≠sico de masa del martillo.
    
    Args:
        masa (float): Masa en kg
        
    Returns:
        tuple: (masa_validada, mensaje)
        
    Ranges:
        - None: 1.0 kg por defecto
        - <= 0: 1.0 kg por defecto
        - < 0.1: Ajustado a 0.1 kg
        - > 50.0: Ajustado a 50.0 kg
        - 0.1-50.0: Valor v√°lido
    """
```

#### **generar_graficos_vacios()**
```python
def generar_graficos_vacios():
    """
    Genera figuras vac√≠as para casos de error.
    
    Returns:
        tuple: 8 elementos (fig_tiempo, fig_fft, fig_waterfall, 
               fig_damping, fig_disp, fig_coherencia, 
               curvas_enfasis, opciones_curvas, estado_fijar_vista, estilo_fijar,
               mediana_val, highpass_val, bandpass_multibanda)
    """
```

---

## üìù **NOTAS DE VERSI√ìN**

---

## üèÖ VALORACI√ìN T√âCNICA Y RECOMENDACIONES

### üîé Valoraci√≥n T√©cnica

La aplicaci√≥n alcanza un nivel profesional y robusto, con una nota t√©cnica de **9/10**. Destaca por su modularidad, flexibilidad, rendimiento y experiencia de usuario. El sistema de cach√©, la optimizaci√≥n para datasets grandes y la visualizaci√≥n avanzada la sit√∫an por encima de la media en aplicaciones cient√≠ficas de an√°lisis experimental.

### üí™ Puntos Fuertes

- Modularidad y claridad del c√≥digo
- Robustez ante errores y datos problem√°ticos
- Flexibilidad para datasets grandes y peque√±os
- Experiencia de usuario cuidada y validaciones autom√°ticas
- Visualizaci√≥n avanzada y exportaci√≥n de resultados
- Sistema de cach√© inteligente y adaptativo

### ‚ö†Ô∏è Puntos D√©biles y √Åreas de Mejora

- **Gesti√≥n de errores y mensajes al usuario:** Los mensajes en la interfaz pueden ser m√°s claros y amigables para usuarios no t√©cnicos.
- **Documentaci√≥n interna y externa:** Mejorar docstrings y comentarios en funciones clave, y a√±adir ejemplos de uso en la documentaci√≥n.
- **Pruebas autom√°ticas:** A√±adir tests unitarios y de integraci√≥n para asegurar la calidad y detectar regresiones.
- **Validaci√≥n de inputs:** Mostrar advertencias visuales si el usuario intenta valores fuera de rango o si el dataset es demasiado peque√±o para ciertos an√°lisis.
- **Rendimiento en datasets muy grandes:** Permitir al usuario ajustar din√°micamente los l√≠mites de rendimiento seg√∫n la capacidad de su sistema.
- **Experiencia de usuario (UX):** A√±adir tooltips, ayuda contextual y ejemplos de uso en la interfaz.
- **Modularidad visual:** Mejorar la separaci√≥n visual entre secciones y ofrecer modo oscuro/claro configurable.

### üõ†Ô∏è Recomendaciones de Mejora

1. A√±adir una gu√≠a de usuario visual con ejemplos y capturas de pantalla.
2. Incluir una secci√≥n de preguntas frecuentes (FAQ) en la documentaci√≥n.
3. Implementar tests autom√°ticos para las funciones principales.
4. Mejorar los mensajes de error y advertencia en la interfaz.
5. Permitir configuraci√≥n avanzada de l√≠mites de rendimiento y visualizaci√≥n.
6. A√±adir ayuda contextual y tooltips en los controles de la interfaz.
7. Documentar con m√°s detalle los algoritmos y m√©todos matem√°ticos empleados.

---

### üÜï **v1.10.3 - ACTUAL**

#### **Nuevas Caracter√≠sticas**
- ‚úÖ **Sistema de cach√© inteligente** con optimizaci√≥n autom√°tica
- ‚úÖ **Indicadores de estado visual** en tiempo real para botones
- ‚úÖ **Optimizaci√≥n de datasets grandes** (>200k puntos)
- ‚úÖ **Limpieza autom√°tica de memoria** al iniciar y cargar archivos
- ‚úÖ **Fallback robusto** en caso de errores
- ‚úÖ **Documentaci√≥n completa** integrada

#### **Mejoras de Rendimiento**
- üöÄ **FFT**: 70-90% m√°s r√°pido con cach√©
- üöÄ **Waterfall**: 80-95% m√°s r√°pido con cach√©
- üöÄ **Cambios de escala**: Instant√°neos (<0.1s)
- üöÄ **Gesti√≥n de memoria**: Autom√°tica y eficiente

#### **Correcciones de Bugs**
- üîß Funci√≥n `mostrar_overlay_cierre` corregida
- üîß Variables inicializadas correctamente en callbacks
- üîß Imports completos a√±adidos
- üîß Validaci√≥n robusta de datos mejorada

#### **Arquitectura**
- üèóÔ∏è **Modularidad**: Funciones bien separadas
- üèóÔ∏è **Conservadora**: No rompe funcionalidad existente
- üèóÔ∏è **Escalable**: F√°cil a√±adir nuevas caracter√≠sticas
- üèóÔ∏è **Mantenible**: C√≥digo bien documentado

---

## üìû **SOPORTE Y CONTACTO**

**¬øC√≥mo obtener soporte y enviar sugerencias?**
Para cualquier problema t√©cnico, duda o sugerencia de mejora, se recomienda contactar al soporte incluyendo la versi√≥n del software, el sistema operativo, una descripci√≥n detallada del problema, los pasos para reproducirlo y archivos de ejemplo si es posible. Las sugerencias para futuras versiones son bienvenidas y ayudan a mejorar la herramienta para todos los usuarios.

### üè¢ **Informaci√≥n Corporativa**
- **Empresa**: EDAI TU
- **Aplicaci√≥n**: Rigidez Din√°mica v1.10.3
- **Tipo**: An√°lisis cient√≠fico/ingenieril
- **Licencia**: Propietaria

### ü§ù **Soporte T√©cnico**
Para soporte t√©cnico, por favor incluir:
1. **Versi√≥n del software**: v1.10.3
2. **Sistema operativo**: Windows/macOS/Linux + versi√≥n
3. **Descripci√≥n del problema**: Detallada
4. **Pasos para reproducir**: Secuencia exacta
5. **Archivos de ejemplo**: Si es posible
6. **Logs de error**: Copiar mensajes completos

### üí° **Sugerencias de Mejora**
Las sugerencias para futuras versiones son bienvenidas:
- **Nuevas caracter√≠sticas**
- **Optimizaciones adicionales**
- **Formatos de archivo adicionales**
- **Algoritmos de an√°lisis avanzados**

---

## üìú **LICENCIA Y DISCLAIMER**

**¬øQu√© implica la licencia y el disclaimer?**
La licencia establece los derechos de uso y las limitaciones de responsabilidad del software. El disclaimer cient√≠fico aclara que los resultados dependen de la calidad de los datos de entrada y que la herramienta es un apoyo para el an√°lisis, no un sustituto del criterio ingenieril. Se recomienda validar experimentalmente los resultados cr√≠ticos y verificar independientemente para aplicaciones sensibles.

### ‚öñÔ∏è **Licencia**
Este software es propiedad de **EDAI TU**. Todos los derechos reservados.

### ‚ö†Ô∏è **Disclaimer Cient√≠fico**
- Los resultados dependen de la **calidad de los datos de entrada**
- Se recomienda **validaci√≥n experimental** de resultados cr√≠ticos  
- El software es una **herramienta de an√°lisis**, no reemplaza el criterio ingenieril
- Los **par√°metros de amortiguamiento** deben interpretarse en contexto f√≠sico

### üîí **Limitaciones de Responsabilidad**
- El software se proporciona **"tal como est√°"**
- **EDAI TU** no se responsabiliza por decisiones basadas en los resultados
- Se recomienda **verificaci√≥n independiente** para aplicaciones cr√≠ticas

---

*üìÖ √öltima actualizaci√≥n: Julio 2025*  
*üìç Versi√≥n de documentaci√≥n: 1.0*  
*üè¢ EDAI TU - Soluciones de Ingenier√≠a Avanzada*

---
